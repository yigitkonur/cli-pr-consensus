// ============================================
// PR Consensus - Markdown Formatter
// ============================================

import { readFileSync, existsSync } from 'fs';
import type { PRConsensusOutput, ParsedComment } from '../types/index.js';

/**
 * Format output as Markdown with optional Go template support
 */
export function formatAsMarkdown(
  data: PRConsensusOutput,
  templatePath?: string
): string {
  // If custom template provided, use it
  if (templatePath && existsSync(templatePath)) {
    return applyTemplate(data, readFileSync(templatePath, 'utf-8'));
  }

  // Default markdown format
  return formatDefaultMarkdown(data);
}

/**
 * Default markdown template
 */
function formatDefaultMarkdown(data: PRConsensusOutput): string {
  const lines: string[] = [];

  // Header
  lines.push(`# PR #${data.pr.number}: ${data.pr.title}`);
  lines.push('');

  // Status line
  lines.push(`> **Status**: ${data.pr.state} | **Review**: ${data.pr.reviewDecision || 'Pending'} | **Author**: @${data.pr.author}`);
  lines.push(`> **Changes**: +${data.pr.additions} -${data.pr.deletions} across ${data.pr.changedFiles} files`);
  lines.push('');

  // PR Description (if present)
  if (data.pr.body && data.pr.body.trim()) {
    lines.push('## Description');
    lines.push('');
    lines.push(data.pr.body);
    lines.push('');
  }

  // Files changed
  lines.push('## Files Changed');
  lines.push('');
  lines.push('| File | Changes | Comments |');
  lines.push('|------|---------|----------|');

  for (const file of data.files) {
    const commentCount = file.commentCount || 0;
    lines.push(`| \`${file.path}\` | +${file.additions} -${file.deletions} | ${commentCount} |`);
  }
  lines.push('');

  // Reviews summary
  if (data.reviews.summary.length > 0) {
    lines.push('## Reviews');
    lines.push('');

    for (const review of data.reviews.summary) {
      const stateEmoji = getStateEmoji(review.state);
      lines.push(`### ${stateEmoji} @${review.author} - ${review.state}`);
      lines.push('');

      if (review.body && review.body.trim()) {
        lines.push(review.body);
        lines.push('');
      }

      if (review.commentCount > 0) {
        lines.push(`*${review.commentCount} inline comment(s)*`);
        lines.push('');
      }
    }
  }

  // General comments
  if (data.comments.general.length > 0) {
    lines.push('## Discussion');
    lines.push('');

    for (const comment of data.comments.general) {
      lines.push(`### @${comment.author} (${formatDate(comment.createdAt)})`);
      lines.push('');
      lines.push(comment.body);
      lines.push('');
    }
  }

  // File-specific comments
  const filesWithComments = Object.entries(data.comments.byFile)
    .filter(([, comments]) => comments.length > 0);

  if (filesWithComments.length > 0) {
    lines.push('## Inline Comments');
    lines.push('');

    for (const [filePath, comments] of filesWithComments) {
      lines.push(`### \`${filePath}\``);
      lines.push('');

      for (const comment of comments) {
        const lineInfo = comment.line ? ` (Line ${comment.line})` : '';
        lines.push(`#### @${comment.author}${lineInfo}`);
        lines.push('');

        if (comment.diffHunk) {
          lines.push('```diff');
          lines.push(comment.diffHunk);
          lines.push('```');
          lines.push('');
        }

        lines.push(comment.body);
        lines.push('');

        if (comment.suggestion) {
          lines.push('**Suggestion:**');
          lines.push('```suggestion');
          lines.push(comment.suggestion);
          lines.push('```');
          lines.push('');
        }
      }
    }
  }

  // CI Status
  if (data.ci && data.ci.checks.length > 0) {
    lines.push('## CI Status');
    lines.push('');
    lines.push(`**Overall**: ${data.ci.status}`);
    lines.push('');

    for (const check of data.ci.checks) {
      const emoji = check.conclusion === 'success' ? 'âœ…' :
                    check.conclusion === 'failure' ? 'âŒ' :
                    check.conclusion === 'pending' ? 'â³' : 'âšª';
      lines.push(`- ${emoji} ${check.name}: ${check.conclusion || check.status}`);
    }
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`*Generated by pr-consensus v${data.meta.version} at ${data.meta.generatedAt}*`);

  return lines.join('\n');
}

/**
 * Apply a Go-style template (simplified implementation)
 * Supports: {{.Field}}, {{range .Array}}...{{end}}, {{if .Field}}...{{end}}
 */
function applyTemplate(data: PRConsensusOutput, template: string): string {
  let result = template;

  // Simple field replacements {{.field}}
  result = result.replace(/\{\{\.(\w+(?:\.\w+)*)\}\}/g, (_, path) => {
    const value = getNestedValue(data, path);
    return value !== undefined ? String(value) : '';
  });

  // Range blocks {{range .array}}...{{end}}
  result = result.replace(
    /\{\{range\s+\.(\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{end\}\}/g,
    (_, path, body) => {
      const array = getNestedValue(data, path);
      if (!Array.isArray(array)) return '';

      return array.map(item => {
        let itemResult = body;
        // Replace {{.}} with the item itself
        itemResult = itemResult.replace(/\{\{\.\}\}/g, String(item));
        // Replace {{.field}} within the range
        itemResult = itemResult.replace(/\{\{\.(\w+)\}\}/g, (_match: string, field: string) => {
          const val = (item as Record<string, unknown>)[field];
          return val !== undefined ? String(val) : '';
        });
        return itemResult;
      }).join('');
    }
  );

  // If blocks {{if .field}}...{{end}}
  result = result.replace(
    /\{\{if\s+\.(\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{end\}\}/g,
    (_, path, body) => {
      const value = getNestedValue(data, path);
      return value ? body : '';
    }
  );

  return result;
}

/**
 * Get nested value from object by dot-separated path
 */
function getNestedValue(obj: unknown, path: string): unknown {
  const parts = path.split('.');
  let current: unknown = obj;

  for (const part of parts) {
    if (current === null || current === undefined) return undefined;
    if (typeof current !== 'object') return undefined;
    current = (current as Record<string, unknown>)[part];
  }

  return current;
}

/**
 * Get emoji for review state
 */
function getStateEmoji(state: string): string {
  switch (state) {
    case 'APPROVED': return 'âœ…';
    case 'CHANGES_REQUESTED': return 'ğŸ”„';
    case 'COMMENTED': return 'ğŸ’¬';
    case 'DISMISSED': return 'ğŸš«';
    case 'PENDING': return 'â³';
    default: return 'ğŸ“';
  }
}

/**
 * Format date for display
 */
function formatDate(isoDate: string): string {
  const date = new Date(isoDate);
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
}
